using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UIElements;

namespace su.Modules;

[RegisterModule]
public class ESP : Module
{
	private bool PlayerESPEnabled;
	private bool MineralESPEnabled;
	private bool DropsESPEnabled;

	private static Camera MainCam;

	private static HitableRock[] Rocks = { };

	protected override void Initialize()
	{
		Name = "ESP";
		WindowId = WindowIDs.Exploit.ToInt();

		StikosekUtilities.Instance.StartCoroutine(RefreshESPRoutine());
	}

	private IEnumerator RefreshESPRoutine()
	{
		while (true)
		{
			yield return new WaitForSeconds(0.5f);

			if (!InGame)
				continue;

			Rocks = Object.FindObjectsOfType<HitableRock>();
		}
	}

	public override void OnRender()
	{
		GUIStyle box = new GUIStyle(GUI.skin.box);
		box.normal.textColor = Color.green;

		GUILayout.BeginVertical("ESP", box);
		GUILayout.Space(20);
		Toggle("Player ESP", ref PlayerESPEnabled);
		Toggle("Mineral ESP", ref MineralESPEnabled);
		Toggle("Drops ESP", ref DropsESPEnabled);
		GUILayout.EndVertical();
	}

	public override void OnGUI()
	{
		if (MainCam == null)
			MainCam = Camera.main;

		if (PlayerESPEnabled)
			DrawPlayerESP();

		if (MineralESPEnabled)
			DrawMineralESP();

		if (DropsESPEnabled)
			DrawDropESP();
	}

	private void DrawDropESP()
	{
		foreach (GameObject itemObj in ItemManager.Instance.list.Values)
		{
			if (itemObj == null)
				continue;

			if (Vector3.Distance(itemObj.transform.position, PlayerMovement.Instance.transform.position) > 300)
				continue;

			// ESP glitches weirdly sometimes without this
			if (IsBehindCamera(itemObj.transform.position))
				continue;

			DrawESP(itemObj.transform.position, Color.blue, 2, -2);
		}
	}


	private void DrawMineralESP()
	{
		foreach (HitableRock res in Rocks)
		{
			if (res == null)
				continue;

			if (Vector3.Distance(PlayerStatus.Instance.transform.position, res.transform.position) > 300)
				continue;

			Color espColor = Color.blue;

			switch (res.entityName)
			{
				case "Coal":
					espColor = Color.black;
					break;
				case "Iron":
					espColor = Color.gray;
					break;
				case "Mithril":
					espColor = Color.blue;
					break;
				case "Gold":
					espColor = Color.yellow;
					break;
				case "Adamantite":
					espColor = Color.green;
					break;
				case "Ruby":
				case "Obamium":
					espColor = Color.magenta;
					break;
			}

			DrawESP(res.transform.position, espColor, 2, -2, res.entityName, new GUIStyle()
			{
				alignment = TextAnchor.MiddleCenter
			});
		}
	}

	private void DrawPlayerESP()
	{
		foreach (PlayerManager player in GameManager.players.Values)
		{
			if (player == null)
				continue;

			if (player.dead)
				continue;

			// ESP glitches weirdly sometimes without this
			if (IsBehindCamera(player.transform.position))
				continue;

			DrawESP(player.transform.position, Color.green, 2, -1);
		}
	}

	private static bool IsBehindCamera(Vector3 position)
	{
		Vector3 cameraPosition = MainCam.transform.position;
		Vector3 objectPosition = position;
		Vector3 cameraForward = MainCam.transform.forward;

		Vector3 toObject = objectPosition - cameraPosition;

		if (Vector3.Dot(toObject, cameraForward) < 0f)
		{
			return true;
		}

		return false;
	}

	private void DrawESP(Vector3 position, Color color, float headOffset, float footOffset, string label = null, GUIStyle labelStyle = null)
	{
		Vector3 w2s_head = MainCam.WorldToScreenPoint(position + new Vector3(0, headOffset, 0));
		Vector3 w2s_foot = MainCam.WorldToScreenPoint(position + new Vector3(0, footOffset, 0));

		if (w2s_head.z < 0 || w2s_foot.z < 0)
			return;

		float height = w2s_foot.y - w2s_head.y;

		Vector2 topLeft = new(w2s_head.x - (height / 4), Screen.height - w2s_head.y);
		Vector2 bottomRight = new(w2s_foot.x + (height / 4), Screen.height - w2s_foot.y);

		if (label != null)
		{
			GUI.Label(new Rect(w2s_head.x, Screen.height - w2s_head.y, 0f, 0f), label, labelStyle);
		}

		CalculateRect(topLeft, bottomRight, out Vector2 topRight, out Vector2 bottomLeft);
		DrawRect(topLeft, topRight, bottomLeft, bottomRight, 1, color);

		//Vector2 bottomMiddle = new(bottomLeft.x + (bottomRight.x - bottomLeft.x), bottomLeft.y);

		//DrawLine(new Vector2(Screen.currentResolution.width / 2, Screen.currentResolution.height / 2), bottomMiddle, 1, Color.green);
	}

	private static Texture2D lineTex;
	private static void DrawLine(Vector2 pointA, Vector2 pointB, float width, Color color)
	{
		Matrix4x4 matrix = GUI.matrix;
		if (!lineTex)
			lineTex = new Texture2D(1, 1);

		Color color2 = GUI.color;
		GUI.color = color;
		float num = Vector3.Angle(pointB - pointA, Vector2.right);

		if (pointA.y > pointB.y)
			num = -num;

		GUIUtility.ScaleAroundPivot(new Vector2((pointB - pointA).magnitude, width), new Vector2(pointA.x, pointA.y + 0.5f));
		GUIUtility.RotateAroundPivot(num, pointA);
		GUI.DrawTexture(new Rect(pointA.x, pointA.y, 1f, 1f), lineTex);
		GUI.matrix = matrix;
		GUI.color = color2;
	}

	private static void CalculateRect(Vector2 topLeft, Vector2 bottomRight, out Vector2 topRight, out Vector2 bottomLeft)
	{
		topRight = new(bottomRight.x, topLeft.y);
		bottomLeft = new(topLeft.x, bottomRight.y);
	}

	private static void DrawRect(Vector2 topLeft, Vector2 bottomRight, float width, Color color)
	{
		CalculateRect(topLeft, bottomRight, out Vector2 topRight, out Vector2 bottomLeft);
		DrawRect(topLeft, topRight, bottomLeft, bottomRight, width, color);
	}

	private static void DrawRect(Vector2 topLeft, Vector2 topRight, Vector2 bottomLeft, Vector2 bottomRight, float width, Color color)
	{
		DrawLine(topLeft, topRight, width, color);
		DrawLine(topRight, bottomRight, width, color);
		DrawLine(bottomRight, bottomLeft, width, color);
		DrawLine(bottomLeft, topLeft, width, color);
	}

}
